# ゲームボーイエミュレーター：実機仕様との差異 完全リスト

このドキュメントでは、現在の実装と実機仕様との間に存在する全ての差異をリストアップしています。

---

## 🎯 最も重要な修正項目（TOP 5）

### 1. 🔴 **Waveチャンネルの周期計算が8倍間違っている**
- **ファイル**: `Sound.kt:1083`
- **現在の実装**: `val period = (2048.0 - frequency) * 16.0`
- **正しい実装**: `val period = (2048.0 - frequency) * 2.0`
- **影響**: Waveチャンネルの音程が実機の8倍高い（オクターブ3つ上）
- **優先度**: 🔴 クリティカル

### 2. 🔴 **Square波のデューティパターンが間違っている**
- **ファイル**: `Sound.kt:704-719`
- **現在の実装**: Duty 3 = `0b11111100` (波形が逆)
- **正しい実装**: Duty 3 = `0b01111110`
- **影響**: Square波の音質が実機と異なる
- **優先度**: 🔴 クリティカル

### 3. 🔴 **フレームシーケンサがDIVレジスタと同期していない**
- **ファイル**: `Sound.kt:82-83`
- **現在の実装**: 独立したカウンタで512Hzを生成
- **正しい実装**: DIVレジスタのbit 4（またはbit 5）の立ち下がりエッジで更新
- **影響**: Length Counter、Envelope、Sweepのタイミングが実機とずれる
- **優先度**: 🔴 クリティカル

### 4. 🔴 **HALTバグの実装が不完全**
- **ファイル**: `Cpu.kt:133-143`
- **現在の実装**: `IF`のみをチェック、PCが1バイトだけ進む
- **正しい実装**: `(IE & IF) != 0`をチェック、次の命令がダブルフェッチされる
- **影響**: HALTバグに依存するゲームが動作しない
- **優先度**: 🔴 クリティカル

### 5. 🔴 **HALT/STOP中のクロック進行が不正確**
- **ファイル**: `Machine.kt:43-56`, `Cpu.kt:126-128`
- **現在の実装**: 常に4サイクル固定
- **正しい実装**: HALT中は実際の経過時間、STOPは完全停止
- **影響**: タイミング依存のゲームで同期ずれ
- **優先度**: 🔴 クリティカル

---

## 🔴 クリティカル（実機との同期に影響する重大な問題）

### 1. CPU実行タイミングの問題

#### 1.1 HALT/STOP中のクロック進行
- **ファイル**: `Machine.kt:43-56`, `Cpu.kt:126-128`
- **現在の実装**:
  ```kotlin
  if (halted || stopped) {
      return Cycles.NOP  // 4サイクルだけ返す
  }
  ```
- **問題**: HALT/STOP中も常に4サイクル固定で進めているため、実機と同期がずれる
- **実機仕様**:
  - HALT中は割り込み発生まで実際の時間が経過する
  - STOP中はCPUとタイマーが完全に停止する（実機ではジョイパッド入力で復帰）
- **修正方法**:
  - HALT中は実際のサイクル数を累積し、割り込み発生時に一括でコンポーネントを更新
  - STOP中は`step()`を完全にスキップ

#### 1.2 HALTバグの不完全な実装
- **ファイル**: `Cpu.kt:133-143`
- **現在の実装**:
  ```kotlin
  if (opcode == 0x76 && !interruptMasterEnabled) {
      val ifReg = bus.readByte(0xFF0Fu.toUShort())
      if (ifReg != 0u.toUByte()) {
          registers.pc = (pcBefore.toInt() + 1).toUShort()
          return Cycles.NOP
      }
  }
  ```
- **問題**:
  - `IF`の値だけをチェックしているが、実機では`IE`との論理積も考慮する
  - HALTバグが発生した場合、次の命令がダブルフェッチされる挙動が未実装
- **実機仕様**:
  - `IME=0` かつ `(IE & IF) != 0` の場合、HALTは実行されずにPCが進まない
  - 次の命令実行時、PCが進まずに同じ命令を2回読み取る（ダブルフェッチ）
- **修正方法**:
  ```kotlin
  if (opcode == 0x76 && !interruptMasterEnabled) {
      val ifReg = bus.readByte(0xFF0Fu.toUShort())
      val ieReg = bus.readByte(0xFFFFu.toUShort())
      if ((ifReg.toInt() and ieReg.toInt()) != 0) {
          // HALTバグ: PCを進めない、次の命令をダブルフェッチ
          haltBugActive = true
          return Cycles.NOP
      }
  }
  ```

### 2. PPUタイミングの不正確さ

#### 2.1 モード3の可変サイクル数が未実装
- **ファイル**: `Ppu.kt`（モード遷移ロジック）
- **問題**: Mode 3（Pixel Transfer）が固定サイクル数で実装されている可能性
- **実機仕様**: Mode 3は172〜289サイクルの可変幅を持つ
  - スプライト数、SCX mod 8、ウィンドウの有無によって変動
  - 基本: 172サイクル + スプライトペナルティ（最大10個 × 6〜11サイクル）
- **修正方法**:
  - スキャンライン開始時にスプライトを評価
  - SCX % 8のペナルティを加算
  - ウィンドウ有効時のペナルティを加算

#### 2.2 スプライト評価のタイミング
- **ファイル**: `Ppu.kt`（OAM Search実装）
- **問題**: Mode 2（OAM Search）で最大10個のスプライトを選択する処理のタイミングが不明確
- **実機仕様**:
  - Mode 2は正確に80サイクル
  - 2サイクルごとに1つのOAMエントリを評価（合計40エントリ）
  - Y座標が一致する最初の10個を選択
- **修正方法**: OAM Searchのサイクル単位シミュレーションを実装

#### 2.3 VRAM/OAMアクセス制限のタイミング
- **ファイル**: `Ppu.kt:84-92`
- **現在の実装**:
  ```kotlin
  fun isVramAccessible(): Boolean = currentMode != PpuMode.PIXEL_TRANSFER
  fun isOamAccessible(): Boolean =
      currentMode != PpuMode.OAM_SEARCH && currentMode != PpuMode.PIXEL_TRANSFER
  ```
- **問題**: モード遷移の瞬間の挙動が不明確（実機はサイクル単位で厳密に制限）
- **実機仕様**: モード遷移と同時にアクセス権が変わる
- **修正方法**: PPUのサイクルカウンタを厳密に管理し、モード遷移時に即座に反映

### 3. タイマーの不正確な実装

#### 3.1 TACレジスタ変更時のエッジ検出
- **ファイル**: `Timer.kt:70-82`
- **現在の実装**:
  ```kotlin
  if (oldBits != newBits) {
      timaCounter = 0  // カウンタをリセット
  }
  ```
- **問題**: 実機ではDIVレジスタの特定ビットの立ち下がりエッジでTIMAを更新する
- **実機仕様**:
  - TIMAは内部的にDIVの特定ビット（TACで選択）の立ち下がりエッジで更新
  - TAC変更時、DIVの該当ビットが1→0になるとTIMAが即座にインクリメント
- **修正方法**:
  - DIVレジスタの内部16bitカウンタを保持
  - TAC変更前後でエッジ検出を行う

#### 3.2 DIV書き込み時の副作用
- **ファイル**: `Timer.kt:54-58`
- **現在の実装**:
  ```kotlin
  0 -> {
      div = 0u
      divCounter = 0
  }
  ```
- **問題**: DIVをクリアした際、TIMAへの影響が考慮されていない
- **実機仕様**:
  - DIV書き込みでクリアされると、内部16bitカウンタもクリア
  - これにより、TIMAの更新タイミングもリセットされる
  - DIVクリア前に該当ビットが1だった場合、立ち下がりエッジが発生してTIMAがインクリメント
- **修正方法**: DIVクリア時にエッジ検出を実行

### 4. 音源（APU）の重大な問題

#### 4.1 フレームシーケンサの同期ずれ
- **ファイル**: `Sound.kt:82-83`
- **現在の実装**:
  ```kotlin
  private var frameSequencerCounter: Double = 0.0
  private var frameSequencerStep: Int = 0
  ```
- **問題**: フレームシーケンサ（512Hz）の更新タイミングが実機と同期していない
- **実機仕様**:
  - フレームシーケンサはDIVレジスタのbit 5（または内部16bitカウンタのbit 12）の立ち下がりエッジで更新
  - DIV書き込みでクリアされるとフレームシーケンサもリセット
  - 8192 Hz（CPU周波数 / 512）でステップが進む
- **修正方法**:
  ```kotlin
  // DIVの内部16bitカウンタを監視
  private var lastDivBit12: Boolean = false

  fun step(cpuCycles: Int) {
      // DIVカウンタ更新後
      val currentDivBit12 = (divInternalCounter and 0x1000) != 0
      if (lastDivBit12 && !currentDivBit12) {
          // 立ち下がりエッジ検出
          advanceFrameSequencer()
      }
      lastDivBit12 = currentDivBit12
  }
  ```

#### 4.2 デューティパターンのビット順序
- **ファイル**: `Sound.kt:704-719`
- **現在の実装**:
  ```kotlin
  val dutyPattern = when (dutyCycle) {
      0 -> 0b00000001  // 12.5%
      1 -> 0b00000011  // 25%
      2 -> 0b00001111  // 50%
      3 -> 0b11111100  // 75%
      else -> 0b00001111
  }
  ```
- **問題**: デューティパターン3の波形が実機と逆になっている
- **実機仕様**:
  - Duty 0 (12.5%): `00000001` (bit 0のみ)
  - Duty 1 (25%):   `10000001` (bit 0, 7)
  - Duty 2 (50%):   `10000111` (bit 0-2, 7)
  - Duty 3 (75%):   `01111110` (bit 1-6)
- **修正方法**:
  ```kotlin
  val dutyPattern = when (dutyCycle) {
      0 -> 0b00000001  // 12.5%
      1 -> 0b10000001  // 25%
      2 -> 0b10000111  // 50%
      3 -> 0b01111110  // 75%
      else -> 0b00000001
  }
  ```

#### 4.3 サンプル生成タイミングの精度問題
- **ファイル**: `Sound.kt:576-654`
- **現在の実装**:
  ```kotlin
  val sampleSoundCycle = frameStartSoundCycle + i * soundCyclesPerSample
  ```
- **問題**:
  - 浮動小数点演算の累積誤差が発生
  - フレーム境界での位相の連続性が保証されていない
  - `soundCycleCounter`が無限に増加し、精度が低下
- **実機仕様**: APUは各チャンネルごとに独立したカウンタを持ち、サイクル単位で正確に更新
- **修正方法**:
  - 整数ベースのカウンタに変更
  - フレーム境界で位相を正確に保持
  - 定期的に正規化を行う

#### 4.4 Waveチャンネルの周期計算の誤り
- **ファイル**: `Sound.kt:1083`
- **現在の実装**:
  ```kotlin
  val period = (2048.0 - frequency) * 16.0  // Squareの2倍
  ```
- **問題**: コメントに「Squareの2倍」とあるが、実際は計算式が8倍になっている
- **実機仕様**:
  - Square周期 = `(2048 - frequency) * 4` CPUサイクル = `(2048 - frequency) * 0.5` サウンドサイクル（誤り）
  - **正しい**: Wave周期 = `(2048 - frequency) * 2` サウンドサイクル
  - Wave周波数 = 65536 / (2048 - frequency) Hz
  - Square周波数 = 131072 / (2048 - frequency) Hz（Waveの2倍）
- **修正方法**:
  ```kotlin
  val period = (2048.0 - frequency) * 2.0  // サウンドサイクル単位
  ```

#### 4.5 Noiseチャンネルの周波数計算
- **ファイル**: `Sound.kt:1017-1027`
- **現在の実装**:
  ```kotlin
  val periodCycles = if (s < 16) {
      if (r == 0) {
          (1L shl s) * 8L
      } else {
          r.toLong() * (1L shl (s + 1)) * 8L
      }
  } else {
      0L
  }
  ```
- **問題**: `r = 0`の場合の処理が実機仕様と計算が合っているが、コメントが不明瞭
- **実機仕様**:
  - Divisor code (r): 0の場合は0.5、1-7の場合はそのまま
  - 周波数 = 524288 Hz / divisor / 2^(s+1)
  - 周期 = divisor * 2^(s+1) / 524288 秒 = divisor * 2^(s+1) サウンドサイクル
  - r=0の場合: 周期 = 0.5 * 2^(s+1) = 2^s サウンドサイクル
- **修正方法**: コメントを追加して明確化（ロジックは正しい）

#### 4.6 NR52レジスタの書き込み制限
- **ファイル**: `Sound.kt:196-200`
- **現在の実装**:
  ```kotlin
  if (!soundEnabled && offset != 0x16 && offset < 0x20) {
      return  // 書き込みを無視
  }
  ```
- **問題**: `NR52[7]=0`の場合、一部のレジスタは書き込み可能だが実装が不正確
- **実機仕様**:
  - `NR52[7]=0`の場合、NR10-NR51は書き込み不可
  - NR52自体と波形RAM（0xFF30-0xFF3F）は書き込み可能
  - Length Counterは読み取り専用として残る
- **修正方法**: Length Counterレジスタへの書き込みのみ許可

---

## 🟡 高優先度（ゲーム動作に影響する問題）

### 5. 割り込み処理の問題

#### 5.1 EI命令の遅延実装の不完全性
- **ファイル**: `Cpu.kt:118-122`
- **現在の実装**:
  ```kotlin
  if (imeEnablePending) {
      interruptMasterEnabled = true
      imeEnablePending = false
  }
  ```
- **問題**: EI直後の次の命令が実行される前に割り込みチェックが入る可能性
- **実機仕様**: EI実行後、次の1命令は必ず実行され、その後で割り込みが有効になる
- **修正方法**: 割り込みチェックのタイミングを命令実行前からIME更新後に変更

#### 5.2 割り込みサービスのタイミング
- **ファイル**: `Machine.kt:49-53`
- **現在の実装**:
  ```kotlin
  val interruptCycles = handleInterrupts()
  if (interruptCycles > 0) {
      timer.step(interruptCycles)
      sound.step(interruptCycles)
  }
  ```
- **問題**: 割り込み処理の20サイクル中、PPUが更新されていない
- **実機仕様**: 割り込みサービス中もPPU/Timer/APUは常に動作している
- **修正方法**:
  ```kotlin
  if (interruptCycles > 0) {
      timer.step(interruptCycles)
      ppu.step(interruptCycles)  // PPUも更新
      sound.step(interruptCycles)
  }
  ```

### 6. DMA転送の即時実行

- **ファイル**: `SystemBus.kt`, `Ppu.kt`（DMA実装）
- **問題**: DMA転送が即座に完了している
- **実機仕様**:
  - DMA転送は160サイクル（40バイト × 4サイクル/バイト）かけて転送される
  - DMA転送中はCPUがバスにアクセスできず、HRAMのみアクセス可能
- **修正方法**:
  - DMAカウンタを追加し、サイクルごとに1バイトずつ転送
  - DMA中のメモリアクセスを制限

### 7. メモリアクセスタイミング

#### 7.1 バス競合の未実装
- **ファイル**: `SystemBus.kt:90-95`
- **問題**: CPUとPPUが同時にVRAMにアクセスしようとした場合の挙動が未実装
- **実機仕様**: CPUのVRAMアクセスがMode 3中に行われた場合、アクセスは無視され0xFFが返る
- **修正方法**: 現在の実装は正しいが、タイミングの精度を向上

#### 7.2 OAM DMAとCPUの同期
- **ファイル**: `SystemBus.kt`, `Ppu.kt`
- **問題**: OAM DMA中のメモリアクセス制限が不完全
- **実機仕様**: DMA中はHRAM（0xFF80-0xFFFE）以外へのアクセスは無視される
- **修正方法**: DMAフラグをSystemBusで確認し、HRAM以外へのアクセスを制限

### 8. シリアル通信の即時転送

- **ファイル**: `SystemBus.kt:64-73`
- **問題**: 実機では8サイクル × 8ビット = 64サイクル（内部クロック）または外部クロック依存
- **実機仕様**: SC[7]=1で転送開始、8ビット転送完了後に割り込み発生
- **修正方法**:
  - シリアル転送カウンタを追加
  - 内部クロック選択時は512サイクル（8KHz）または8192サイクル（1KHz）で転送
  - 外部クロックは無視（リンクケーブル未接続）

---

## 🟢 中優先度（精度に影響する問題）

### 9. PPU描画の問題

#### 9.1 スプライト優先順位
- **ファイル**: `Ppu.kt`（スプライト描画ロジック）
- **問題**: X座標 vs OAMインデックスの優先順位
- **実機仕様**: X座標が同じ場合、OAMインデックスが小さいスプライトが優先（DMGの場合）
- **修正方法**: スプライトソート時にX座標が同じ場合はOAMインデックスで安定ソート

#### 9.2 ウィンドウ描画の不完全性
- **ファイル**: `Ppu.kt`（ウィンドウ描画）
- **問題**: ウィンドウの描画が未完成
- **実機仕様**:
  - ウィンドウはWX-7, WY座標から表示
  - 背景より優先度が高い
  - ウィンドウ内部カウンタは一度開始すると停止しない
- **修正方法**: ウィンドウ描画ロジックを完成させる

#### 9.3 LCD無効中の挙動
- **ファイル**: `Ppu.kt`（LCD制御）
- **問題**: LCD OFF中のLY/STAT/モード挙動
- **実機仕様**:
  - LCD無効時、LY=0、Mode=0（HBlank）
  - VBlank割り込みは発生しない
  - 画面は白（すべてのピクセルが最も明るい色）
- **修正方法**: LCDC[7]=0時の挙動を実装

### 10. MBC1のバンク切り替え

- **ファイル**: `Mbc1.kt`
- **問題**: 複雑なバンキングモード（ROM/RAMモード切り替え）の挙動が未検証
- **実機仕様**:
  - MBC1には16Mbit ROMモードと4Mbit ROM + 32KB RAMモードがある
  - 0x6000-0x7FFFへの書き込みでモード切り替え
- **修正方法**: MBC1のモード切り替えロジックを検証・修正

### 11. セーブデータの永続化

- **ファイル**: `GameBoyCoreImpl.kt`（セーブ機能）
- **問題**: カートリッジRAMの保存機能が未実装
- **実機仕様**: バッテリバックアップRAMはゲーム終了後も内容が保持される
- **修正方法**:
  - `.sav`ファイルの読み書き機能を実装
  - ゲーム起動時にロード、終了時に保存

---

## 🔵 低優先度（動作には影響しないが正確性に欠ける問題）

### 12. CPU命令の未実装または不正確な挙動

#### 12.1 未使用オペコードの処理
- **ファイル**: `Cpu.kt`（executeByOpcode）
- **問題**: 未使用オペコード（0xD3, 0xDB, 0xDD, 0xE3, 0xE4, 0xEB, 0xEC, 0xED, 0xF4, 0xFC, 0xFD）の処理が未定義
- **実機仕様**: これらのオペコードは不定動作（通常はロックアップまたはNOP相当）
- **修正方法**: 未使用オペコードを検出してログ出力または例外スロー

#### 12.2 DAA命令の精度
- **ファイル**: `Cpu.kt`（DAA実装）
- **問題**: DAA（Decimal Adjust Accumulator）命令の実装が複雑で、エッジケースの検証が不十分な可能性
- **実機仕様**: BCD演算の補正を行う複雑なロジック
- **修正方法**: blarggのDAA testROMで検証

### 13. I/Oレジスタの未実装

- **ファイル**: `SystemBus.kt:143`
- **問題**: 0xFF50-0xFF7Fのその他I/Oレジスタが未実装
- **実機仕様**:
  - 0xFF50: ブートROM無効化レジスタ（一度だけ書き込み可能）
  - 0xFF4D: KEY1 - Speed switch (CGB専用)
  - 0xFF4F: VBK - VRAM bank (CGB専用)
  - 0xFF51-0xFF55: HDMA (CGB専用)
  - 0xFF56: RP - Infrared (CGB専用)
  - 0xFF68-0xFF6B: BGP/OBP color palette (CGB専用)
  - 0xFF70: SVBK - WRAM bank (CGB専用)
- **修正方法**: DMGでは0xFF50のみ実装、他はCGB対応時に実装

### 14. 未実装の仕様詳細

#### 14.1 PPUのスプライトフェッチ
- **ファイル**: `Ppu.kt`（Mode 3実装）
- **問題**: スプライトのタイルデータフェッチに6-11サイクルかかる挙動が未実装
- **実機仕様**: Mode 3の長さはスプライト数に依存
- **修正方法**: Mode 3のサイクル計算を正確に実装

#### 14.2 サウンドのパワーオン時の初期化
- **ファイル**: `Sound.kt:59-67`
- **問題**: サウンドレジスタのパワーオン時の初期値が一部不正確な可能性
- **実機仕様**:
  - NR52 = 0xF1 (サウンド有効、全チャンネル無効)
  - NR10-NR51 = 未定義または0
- **修正方法**: パワーオン時の初期値を実機と合わせる

---

## 📊 修正優先順位まとめ

### Phase 1: 🔴 クリティカル修正（音源・クロック）
1. ✅ **Waveチャンネル周期修正** - `Sound.kt:1083`
2. ✅ **デューティパターン修正** - `Sound.kt:715`
3. ✅ **フレームシーケンサ同期** - `Sound.kt` + `Timer.kt`
4. ✅ **サンプル生成精度** - `Sound.kt:576-654`
5. ✅ **HALTバグ完全実装** - `Cpu.kt:133-143`
6. ✅ **HALT/STOPクロック** - `Machine.kt`, `Cpu.kt`

### Phase 2: 🟡 高優先度修正（ゲーム互換性）
7. PPUモード3可変タイミング
8. タイマーエッジ検出
9. DMA段階的実行
10. 割り込み時PPU更新

### Phase 3: 🟢 中優先度修正（精度向上）
11. ウィンドウ描画完成
12. スプライト優先順位
13. セーブデータ永続化
14. LCD OFF時の挙動

### Phase 4: 🔵 低優先度修正（エッジケース）
15. 未使用オペコード処理
16. I/Oレジスタ実装
17. PPUスプライトフェッチ精度

---

## 🧪 テスト方法

### 推奨テストROM
1. **blargg's test ROMs**
   - `cpu_instrs.gb` - CPU命令テスト
   - `instr_timing.gb` - 命令タイミングテスト
   - `mem_timing.gb` - メモリアクセスタイミングテスト
   - `dmg_sound.gb` - サウンドテスト

2. **mooneye-gb test ROMs**
   - `acceptance/` - 基本動作テスト
   - `emulator-only/` - エミュレータ特有のテスト

3. **商用ゲーム**
   - ポケモン赤/緑 - MBC1, タイマー, サウンド
   - スーパーマリオランド - PPUタイミング
   - テトリス - 基本動作
   - ゼルダの伝説 - MBC1, セーブ機能

---

## 📝 注意事項

- このリストは現在のコード分析に基づいています
- 実機との完全な互換性を得るには、各修正後にテストROMで検証が必要です
- 一部の問題は相互に依存しているため、修正順序が重要です
- クリティカルな問題（Phase 1）を優先的に修正することを強く推奨します
